## 一 函数概述

### 1.1 函数三种创建方式

在 JS 中，函数有三种创建方式：

```js
//方式一：直接量声明
function fn1() {
  console.log("函数1");
}

//方式二：函数表达式
var fn2 = function () {
  console.log("函数3");
};

//方式三：创建 Function对象实例。Function函数的参数可以有多个，最后一个参数会被看做函数体。
// 不推荐该方式：该语法会导致解析两次代码，第一次解析JS代码，第二次解析传入构造函数中的字符串，造成性能降低
var fn3 = new Function("console.log('函数2')");
```

注意：函数是 JS 一种特殊的引用类型，在较新的 V8 中，打印函数的数据类型，会输出 function

```js
function fn() {
  console.log("函数");
}
console.log(typeof fn); // function
```

### 1.2 函数参数

arguments 存储的是传递过来的实参，JS 在创建函数的同时，会在函数内部创建一个 arguments 对象实例，arguments 对象只有函数开始时才可用。

arguments 对象并不是一个数组，访问单个参数的方式与访问数组元素的方式相同。

arguments 对象的长度由实参个数决定，而不是由形参个数决定。

```javascript
function fn(a, b) {
  console.log(fn.length); //输出：函数的形参的个数 2
  console.log(arguments); //输出：{ '0': 1, '1': 2 }
  console.log(arguments.length); // 输出实参个数2
}
fn(1, 2);
```

### 1.3 函数返回值

在函数内部用 return 来返回计算结果，一个函数只能返回一个值，同时会终止代码的执行：

- 如果函数没有显式的使 return 语句 ，那么函数有默认的返回值：undefined；
- 如果函数使用 return，但 return 后面没有任何值，函数返回值也是：undefined；

### 1.4 重载

JavaScript 的函数没有重载！

重载是 Java 等语言中函数的一个特性，如果两到多个函数，其函数的函数名相同，但是参数、返回值不同，则视为 2 个不同的函数！

## 二 作用域

### 2.1 变量分类

变量分类：

- 全局变量：又称成员变量，在哪里都可访问到，如进入脚本后立即定义的变量、没有用 var 定义的变量。
- 局部变量：函数内部的变量，只有函数内部可以访问到。

### 2.2 作用域

作用域包含：

- 块级作用域：代码块级别的作用域。JavaScript 中没有块级作用域(JS 天坑之一！！)，但是 ES6 中提供了 `let const` 等支持块级类似块级作用域。
- 词法作用域：在代码写好的那一刻，变量的作用域已经确定。

JS 支持词法作用域：

```js
var a = 123;

function f1() {
  console.log(a);
}

function f2() {
  var a = 456;
  f1();
}

f2(); //得到结果123---这里是词法作用域，执行f1()，直接进入f1()内部查找变量，找不到，去全局查找
```

**在 JavaScript 中只有函数能产生作用域！！！**

### 2.3 作用域链

> 作用域链：函数可以形成作用域，如果函数被嵌套在其他函数中，那么外部函数也有自己的作用域，一直往上到全局环境，就形成了一个作用域链。

示例：

```js
var num = 3;
function outer()){
  function inner(){
    function fn(){
        console.log(num);
    }
  }
}
outer();
```

fn 函数的作用域链：fn-->inner 函数作用域-->outer 作用域-->全局作用域。查找数据时，会沿着这个链条一直向上查找。
