## 一 网络安全传输

### 1.1 SSL简介

传统的网络传输中，内容都是以明文形式传输，安全性很低。而对于HTTP、FTP协议而言，我们同样希望其本身只是负责数据的传输而不是加密解密。SSL是当年的网景公司（火狐的前身）退出的安全协议，它会在传输层提供对网络连接的加密功能。对于应用程序而言，数据在传递到应用层之前就已经完成了加密、解密的过程。SSL经过标准化后，称呼为TLS。   

HTTPS 即 SSL 和 HTTP 结合产物，WSS 即 SSL 和 WebSocket结合的产物。  

当然HTTPS由于引入了加密解密过程，而且这种加密机制使用的是非对称加密，其算法性能很低，所以HTTPS也因此牺牲了很大一部分性能。

### 1.2 SSL实现

不同的SSL握手过程存在差异，分为以下三种：
- 只验证服务器
- 验证服务器和客户端
- 恢复原有会话

这里只介绍第一种过程。  

**第1步**：客户端发送一个消息给服务端
```
客户端发送Client Hello消息。
该消息包括SSL版本信息，一个随机数（假设它是random1）、一个session id(用来避免后续请求的握手)和浏览器支持的密码套件（cipher suite）。  
cipher suite是由加密算法名称组成的字符串，包括了4种用途的加密算法：密钥交换算法（RSA等）、数据加密算法（AES256等）、报文认证信息码（MAC）算法（MD5、SHA等）、伪随机数（PRF算法）
cipher suite字符串示例：TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
```

**第2步**：服务器对消息进行验证，服务器确定本次通信使用的SSL版本和其他信息，发送Server Hello给客户端。Server Hello 里面的内容包括服务器支持的SSL版本信息，一个伪随机数（假设它是random2）、服务器的密码套件（cipher suite）。  

**第3步**：服务器发送CA证书给客户端  

**第4步**：服务器发送Server Hello done  

**第5步**：客户端验证服务器证书的合法性后(Certificate Verify)后，利用证书中的公钥加密premaster secret(一个在堆成加密密钥生成中的46字节随机数字，以及消息认证代码)作为Client Key Exchange的消息发送给服务器。  

**第6步**：SSL客户端发送Change Cipher Spec消息，该消息属于SSL密码变化协议  

**第7步**：客户端计算历史消息的hash值，然后使用服务器公钥加密后发送给服务器，服务器进行同样的操作，然后两个值结果相同表示密钥交换成功  

**第8步**：服务器发送 Change Cipher Spec消息  

**第9步**：服务器计算历史消息的hash值，通过交换后的密钥加密，将其作为finished消息发送给客户端，客户端利用交换后的密钥解密，如果和本地历史消息相同就黄泽宁服务器身份，握手结束

### 1.3 密钥交换步骤

无论加密数据使用的是非对称加密还是对称加密，客户端和服务器都要交换密钥：
- 对称加密：又称为私钥加密或者会话密钥加。客户端需要将解密的密钥发送给服务器。发送方和接收方使用同一个密钥去加密解密数据，速度较快。
- 非对称加密：又称公钥密钥加密。需要把自己的私钥发给对方。使用不同的密钥来分别完成加密和解密操作，一个公开发布，即公钥，一个用户自己保存，即私钥。信息发送者用公钥去加密，信息接收者使用私钥

常见的密钥交换算法是RSA算法，是一种非对称加密算法，步骤如下：
- 步骤1：Client Verify。客户端接收到服务端传来的整数后，先验证该证书合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数random3，再用服务端公钥加密random3生成PreMasterKey
- 步骤2：Clent Key Exchange：将第一步最后生成的key传给服务端，服务端用自己的私钥解出这个key，得到客户端生成的random3，再加上random1，random2，至此，客户端和服务端都拥有了random1，random2，random3.

两边再根据同样的算法就可以生成一份密钥，握手结束后应用层数据都是用该密钥进行对称加密，使用三个随机数的原因是提升暴力破解难度。

### 1.4 CA证书与中间人攻击

上述的步骤就像两个同学上课传纸条，二人为了不让其他人发现纸条的信息，互相约定了写法和破译，各自的加密内容只有自己的解密办法才能破译，那么在传输信息前需要双方交换自己的加方法（公钥）。  

然而在第一次交换加密方法的纸条传递时，中间负责传递的同学把交换双方的公钥都换成了自己伪造的公钥，那么就可以轻松使用自己的私钥读取她们的通信内容，这就是中间人攻击。  

CA是第三方组织，用来验证证书合法性，即在上述案例中，纸条由互相信任的班主任传递。

## 二 创建证书

制作公钥与私钥：
```
# 生成服务端私钥
openssl genrsa -out server.key 1024

# 生成服务端公钥
openssl rsa -in server.key -pubout -out server.pem

# 生成客户端私钥
openssl genrsa -out client.key 1024

# 生成客户端公钥
openssl rsa -in client.key -pubout -out client.pem
```

公钥和私钥仍然不能完全预防破解、窃听的可能，典型的例子是中间人攻击。客户端和服务端在交换公钥的过程中，中间人对客户端扮演服务端角色，对服务端扮演客户端角色，客户端和服务端就不再感受到有中间人的存在。为了解决这个问题，数据传输还需要对得到的公钥进行认证，以确认得到的公钥是出自目标服务器！这便是数字认证，一般使用第三方数字证书颁发机构CA制作的证书，这个证书中具有CA通过自己的刚要和私钥实现的签名。  

为了得到签名证书，服务端需要通过自己的私钥生成CSR证书签名请求文件，CA机构通过该文件办法属于该服务端的签名证书，只要通过CA机构就能验证证书是否合法。  

通过CA机构办法证书相当复杂耗时，中小企业一般采用自签名来构建安全网络，就是自己扮演CA机构，给自己的服务端办法签名证书，下面步骤即是制作扮演CA角色需要的文件：
```
openssl genrsa -out ca.key 1024
openssl req -new -key ca.key -out ca.csr
openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt
```

服务端此时需要向CA机构申请签名证书，在申请前要创建自己的CSR文件（Common Name要匹配服务器域名）：
```
openssl req -new -key server.key -out server.csr
```

得到CSR文件后，向自己的CA机构申请签名：
```
openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt
```

客户端在发起安全连接前先回去获取服务端的证书，通过CA的证书验证服务端证书、服务器名称、服务器IP的真伪，如下图所示：  

![](../images/node/04-06.png)  

CA机构将证书颁发给服务端后，证书在请求过程中会被发送给客户端，客户端需要通过CA的证书验证真伪，如果是知名的CA机构，它们的证书一般会预装在浏览器中，如果是自己扮演的CA机构，颁发自有签名则没有该福利！！  

注意：签名证书是一环一环的颁发的，但是在CA那里的证书是不需要上级证书参与签名的，这个证书通常称为根证书。