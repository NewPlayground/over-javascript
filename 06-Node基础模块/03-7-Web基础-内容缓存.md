## 一 内容缓存

一些静态文件，尤其是 html、css 等，往往改动很小，每次访问都要请求的话，就会造成不必要的传输。

为了提高性能，常见的规则是：

- 添加 Expires 或 Cache-Control 到报文头部
- 配置 ETages
- 让 Ajax 可缓存

如何让浏览器缓存静态资源？需要浏览器与服务端一起完成，一般 POST、DELETE、PUT 等请求不会做任何缓存，大多缓存都应用在 GET 请求中。

![](../images/node/session-01.png)

在上图中，本地没有文件时，浏览器会直接请求服务端内容，并将该部分内容放置在本地的某个缓存目录中。在第二次请求时，它对本地文件进行检查，如果不能确定这份本地文件是否可以直接使用，将会发起一次条件请求，即在 GET 请求报文中，附带 If-Modified-Since 字段：

```
If-Modified-Since: Sun, 03 Feb 2013 06:01:12 GMT
```

它将循环服务端是否有更新的版本，本地文件的最后修改时间。如果服务端没有新版本，只需要响应一个 304 状态码，客户端使用本地版本。如果服务端有新的版本，就会将新的内容发送给客户端，客户端放弃本地版本，代码如下所示：

```js
var handle = function (req, res) {
  fs.stat(filename, function (err, stat) {
    var lastModified = stat.mtime.toUTCString();
    if (lastModified === req.headers["if-modified-since"]) {
      res.writeHead(304, "Not Modified");
      res.end();
    } else {
      fs.readFile(filename, function (err, file) {
        var lastModified = stat.mtime.toUTCString();
        res.setHeader("Last-Modified", lastModified);
        res.writeHead(200, "Ok");
        res.end(file);
      });
    }
  });
};
```

这里的条件请求采用时间戳方式实现，会有一些缺陷：

- 文件的时间戳改动但是内容并不一定改动
- 时间戳只能精确到秒级别，更新频繁的内容无法生效

为此 HTTP1.1 引入了 ETag（Entity Tag）解决该问题。由服务端根据文件内容生成散列值，条件请求不会受到时间戳改动造成的带宽浪费：

```js
var getHash = function (str) {
  var shasum = crypto.createHash("sha1");
  return shasum.update(str).digest("base64");
};
```

与 If-Modified-Since/Last-Modified，ETag 的请求响应是 If-None-Match/ETag：

```js
function handle(req, res) {
  fs.readFile(filename, function (err, file) {
    var hash = getHash(file);
    var noneMatch = req.headers["if-none-match"];
    if (hash === noneMatch) {
      res.writeHead(304, "Not Modified");
      res.end();
    } else {
      res.setHeader("ETag", hash);
      res.writeHead(200, "Ok");
      res.end(file);
    }
  });
}
```

浏览器在收到 ETag: "83-1359871272000"这样的响应后，在下次请求中，会将其放置在请求头中：If-None-Match:"83-1359871272000"。

条件请求现在可以在没有文件内容修改的情况下节省带宽，但是依然发起了一个 HTTP 请求，客户端也仍然需要一定的时间等待响应。可见最好的方案是请求也不用发起。那么浏览器如何知晓是否能够直接使用本地版本呢？

答案：服务端在响应时，在响应里设置 Expires 或者 Cache-Control 头，让浏览器明确将内容缓存。Expires 是一个 GMT 格式的时间字符串，浏览器接收到这个过期值后，只要本地还存在该缓存文件，在到期时间之前都不会再发起请求。

```js
function handle(req, res) {
  fs.readFile(filename, function (err, file) {
    var expires = new Date();
    expires.setTime(expires.getTime() + 10 * 365 * 24 * 60 * 60 * 1000);
    res.setHeader("Expires", expires.toUTCString());
    res.writeHead(200, "Ok");
    res.end(file);
  });
}
```

但是该方案的缺陷是浏览器与服务端之间的时间可能不一致，可能造成文件提前过期，或者本应该过期，却未删除，Cache-Control 的功能更丰富：

```js
function handle(req, res) {
  fs.readFile(filename, function (err, file) {
    res.setHeader("Cache-Control", "max-age=" + 10 * 365 * 24 * 60 * 60 * 1000);
    res.writeHead(200, "Ok");
    res.end(file);
  });
}
```

上面代码为 Cache-Control 设置了 max-age 值，能够避免浏览器与服务端时间不同步带来的问题，只要进行类似倒计时的方式计算过期时间即可。此外 Cache-Control 还提供了 public、private、no-cache、no-store 等更精细的而控制缓存选项。

注意：HTTP1.0 不只是 max-age，如果浏览器中两个值同时存在，且被同时支持，则 max-age 会覆盖 Expires。

## 二 缓存清除

缓存一旦设定，服务端意外更新内容时，就无法通知客户端更新。所以需要在花奴才能时为其设定版本号，浏览器是依据 URL 进行缓存的，一旦有内容更新，我们就让浏览器发起新的 URL 请求，使得新的内容能够被客户端更新，一般更新机制有两种：

- 每次发布，路径中跟随 Web 应用的版本号：http://url.com/?v=20130501
- 每次发布，路径中跟随该文件内容的 hash 值：http://url.com/?hash=afadfadwe

整体来说，根据文件内容的 hash 值进行缓存淘汰会更加高效，因为文件内容不一定随着 web 应用的版本而更新，而内容没有更新时，版本号的改动导致的更新毫无意义，所以以文件内容形成哈希值更精准。
