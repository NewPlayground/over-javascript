## 四 HTTP 协议

HTTP 协议是 TCP/IP 协议的一个子集，是超文本传输协议，在该协议规范下，允许将超文本标记语言 HTML 文档从 web 服务器传送到客户端（浏览器）。

包含的方法有：

- GET: 默认的方法，用来请求已经被 URI 识别的资源
- POST: 与 GET 类似，但是一般用来传输实体的主题，其目的不是为了获取响应主体内容，而是一般用于提交大批量的表单数据
- PUT: 与 POST 类似，但是 PUT 是幂等的（多次重复造作结果一致），POST 不是幂等的，所以 PUT 一般用于更新数据 ！
- HEAD: 只用于获取报头，所以可以用来测试链接的有效性
- DELETE: 用于删除资源，与 PUT 相反或者说对应
- OPTIONS: 用来查询针对请求 URI 的资源的方法是否支持
- TRACE: 回显服务器收到的请求，用于测试、诊断
- CONNECT: 开启客户端与服务端资源之间的通道

HTTP 请求的结果用状态码来表示请求的结果：

- 1xx：表示消息，代表请求被接受，需要继续处理，是一种临时响应
- 2xx：表示成功。
  - 200：OK，请求成功，处理成功
  - 202：Accepted，请求已接受，但是处理未完成
  - 206：Partial Content，部分请求被处理完成。断点续传中会用到。
- 3xx：表示重定向，代表客户端采取进一步操作才能完成请求，后续的请求地址（重定向目标）在本次响应的 Location 域中指明
  - 301：Moved Permanently，永久重定向，请求的资源被永久移动到了新 URI
  - 302：Found，临时移动，客户端后续请求应该继续使用原有 URI
- 4xx：表示请求错误。
  - 400：Bad Request，客户端请求语法错误，服务器无法理解
  - 401：Unauthorized，请求要求用户的身份认证
  - 403：Forbidden，服务器理解了客户端的请求，但是拒绝执行，
  - 404：Not Found，服务器未找到对应资源
- 5xx：表示服务器错误。
  - 500：Internal Server Error，服务器内部错误，请求无法完成
  - 502：Bad Gateway，网关或者代理服务器收到了无效请求

## 五 内容协商机制

内容协商机制：客户端和服务端就响应的资源内容进行交涉，以提供最适合当前客户端需求的资源。比如给英语地区的客户端显示英语界面，给汉语地区的客户端显示汉语界面。

内容协商一般以响应资源的语言、字符集、编码等方式作为判断基准。

协商方式有：

- 客户端驱动：客户端发送请求，服务端返回可选列表，客户端做出选择后发送二次请求
- 服务端驱动：客户端发送请求，服务端 根据请求头部集，直接判断选择哪个版本的页面。该方式使用较为广泛。
  - 常用判断头部：Accept，Accept-Language、Accpet-Charset、Accept-Encoding
  - 常用判断头部：Content-Type，Content-Language
- 透明协商：某个中间设备（通常是缓存代理）代表客户端进行协商

## 六 HTTPS

Http 在网络中是以明文形式传输的，其安全性极差，HTTPS 就是为了解决 HTTP 安全性问题而诞生的。

HTTPS 其本质仍然是基于 http 协议，在此基础上增加了 TLS 传输层加密协议（前身是 SSL 协议），所以 HTTPS 可以简单理解为：

```
HTTPS = HTTP + TLS
```

## 七 HTTP 的瓶颈

HTTP 协议已经很古老，目前广泛使用的 HTTP 协议版本为 http1.1，该版本支持缓存处理、长连接、请求流水线处理等，但是仍然不符合当前 4G、5G 的发展。

http2.0 在性能上有了大幅提升，特点如下：

- 基于二进制格式进行数据解析，性能极高。http1.1 是基于文本的。
- 多路复用：连接是共享的，每一个 request 都是用作连接共享机制的，一个 req 对应一个 id，接收方根据 id 归属到不同的服务端请求里。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升
- header 压缩：通讯双方各自缓存一份 header fields 表，避免 header 的重复传输，减小传输文件大小。而 http1.1 则每次请求都附带大量的 header 信息
- 服务端推送：即支持从服务端主动推送信息给客户端

HTTP2.0 中的多路复用和 HTTP1.1 中的长连接复用区别：

```
HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
HTTP/1.1 Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
HTTP/2 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；
```

![](../images/net/net-07.png)
